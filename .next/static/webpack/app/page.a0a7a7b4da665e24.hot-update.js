"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/@emotion/react/jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js\");\n/* harmony import */ var _components_CanvasModal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/CanvasModal */ \"(app-pages-browser)/./src/components/CanvasModal.tsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/** @jsxImportSource @emotion/react */ /* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst Canvas = ()=>{\n    _s();\n    const [polygons, setPolygons] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedPolygonIndex, setSelectedPolygonIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"None\");\n    const [predictionRange, setPredictionRange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0.5);\n    const [scaleFactor, setScaleFactor] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1.0);\n    const [currentPolygon, setCurrentPolygon] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isWheelDown, setIsWheelDown] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [startPos, setStartPos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [fileContent, setFileContent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [showModal, setShowModal] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [modalPos, setModalPos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [modalPolygonIndex, setModalPolygonIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoveredPolygonIndex, setHoveredPolygonIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [photoMounts, setPhotoMounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const dragStart = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const img = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Image());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let isVisible = false;\n        polygons.forEach((polygon)=>{\n            if (polygon.labelIndex === selectedPolygonIndex && polygon.prediction >= predictionRange) {\n                isVisible = true;\n            }\n        });\n        if (!isVisible) {\n            setSelectedPolygonIndex(\"None\");\n        }\n    }, [\n        predictionRange,\n        polygons,\n        selectedPolygonIndex\n    ]);\n    0;\n    const getColorForPolygon = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((labelIndex)=>{\n        const colors = [\n            \"rgba(255, 0, 0, 0.5)\",\n            \"rgba(255, 140, 0, 0.5)\",\n            \"rgba(255, 255, 0, 0.5)\",\n            \"rgba(0, 255, 0, 0.5)\",\n            \"rgba(0, 0, 255, 0.5)\",\n            \"rgba(255, 153, 504, 0.5)\"\n        ];\n        return colors[labelIndex % colors.length];\n    }, []);\n    const increaseOpacity = (color)=>{\n        const [r, g, b, a] = color.match(/\\d+/g).map(Number);\n        const increasedOpacity = Math.min(a + 0.2, 1);\n        return \"rgba(\".concat(r, \", \").concat(g, \", \").concat(b, \", \").concat(increasedOpacity, \")\");\n    };\n    const drawPolygon = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((polygon, ctx)=>{\n        if (polygon.prediction < predictionRange) {\n            return;\n        }\n        let fillColor = polygon.color;\n        if (polygon.labelIndex === selectedPolygonIndex || polygon.labelIndex === modalPolygonIndex || hoveredPolygonIndex === polygon.labelIndex) {\n            fillColor = increaseOpacity(fillColor);\n        }\n        ctx.beginPath();\n        polygon.points.forEach((param, index)=>{\n            let [x, y] = param;\n            const adjustedX = x * img.current.width;\n            const adjustedY = y * img.current.height;\n            if (index === 0) {\n                ctx.moveTo(adjustedX, adjustedY);\n            } else {\n                ctx.lineTo(adjustedX, adjustedY);\n            }\n        });\n        ctx.closePath();\n        ctx.fillStyle = fillColor;\n        ctx.fill();\n        ctx.stroke();\n        const centroid = polygon.points.reduce((acc, param)=>{\n            let [x, y] = param;\n            acc.x += x;\n            acc.y += y;\n            return acc;\n        }, {\n            x: 0,\n            y: 0\n        });\n        centroid.x = centroid.x / polygon.points.length * img.current.width * scaleFactor + startPos.x;\n        centroid.y = centroid.y / polygon.points.length * img.current.height * scaleFactor + startPos.y;\n        if (polygon.tag || polygon.description) {\n            ctx.font = \"16px Arial\";\n            ctx.fillStyle = \"black\";\n            ctx.textAlign = \"center\";\n            let textToDisplay = polygon.tag;\n            ctx.fillText(textToDisplay, centroid.x, centroid.y);\n        }\n    }, [\n        predictionRange,\n        selectedPolygonIndex,\n        modalPolygonIndex,\n        hoveredPolygonIndex,\n        scaleFactor,\n        startPos,\n        img\n    ]);\n    const drawCurrentPolygon = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((ctx)=>{\n        if (currentPolygon.length > 0) {\n            ctx.beginPath();\n            currentPolygon.forEach((param, index)=>{\n                let [x, y] = param;\n                if (index === 0) {\n                    ctx.moveTo(x * img.current.width, y * img.current.height);\n                } else {\n                    ctx.lineTo(x * img.current.width, y * img.current.height);\n                }\n            });\n            ctx.closePath();\n            ctx.stroke();\n        }\n    }, [\n        currentPolygon\n    ]);\n    const drawImageAndPolygons = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.translate(startPos.x, startPos.y);\n        ctx.scale(scaleFactor, scaleFactor);\n        ctx.drawImage(img.current, 0, 0);\n        // polygons.forEach(polygon => drawPolygon(polygon, ctx));\n        polygons.forEach((polygon)=>{\n            if (polygon.prediction >= predictionRange) {\n                drawPolygon(polygon, ctx);\n            }\n        });\n        drawCurrentPolygon(ctx);\n        // polygons.forEach((polygon, index) => {\n        //   drawPolygon(polygon, ctx, index);\n        // });\n        // tags.forEach(tag => {\n        //   ctx.fillText(tag.text, tag.x, tag.y);\n        // });\n        ctx.restore();\n    }, [\n        polygons,\n        drawPolygon,\n        startPos,\n        scaleFactor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        img.current.src = \"/test58.jpg\";\n        img.current.onload = ()=>{\n            drawImageAndPolygons();\n        };\n    }, [\n        drawImageAndPolygons\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        drawImageAndPolygons();\n    }, [\n        predictionRange,\n        drawImageAndPolygons\n    ]);\n    // const isNearStartPoint = (point, startPoint) => {\n    //   const distance = Math.sqrt(Math.pow(point[0] - startPoint[0], 2) + Math.pow(point[1] - startPoint[1], 2));\n    //   return distance < 0.01;\n    // };\n    // const drawCurrentPolygonWithNewPoint = useCallback((newPoint) => {\n    //   const canvas = canvasRef.current;\n    //   const ctx = canvas.getContext('2d');\n    //   drawCurrentPolygon(ctx);\n    //   if (currentPolygon.length > 0) {\n    //     ctx.beginPath();\n    //     currentPolygon.forEach((point, index) => {\n    //       const adjustedX = point[0] * canvas.width;\n    //       const adjustedY = point[1] * canvas.height;\n    //       if (index === 0) {\n    //         ctx.moveTo(adjustedX, adjustedY);\n    //       } else {\n    //         ctx.lineTo(adjustedX, adjustedY);\n    //       }\n    //       console.log(adjustedX, adjustedY);\n    //     });\n    //     ctx.lineTo(newPoint[0] * canvas.width, newPoint[1] * canvas.height);\n    //     ctx.stroke();\n    //   }\n    // }, [currentPolygon, drawCurrentPolygon]);\n    const distanceBetween = (x1, y1, x2, y2)=>{\n        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    };\n    const handleCanvasClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        if (showModal) {\n            return null;\n        }\n        const completionThreshold = 0.007;\n        const rect = canvasRef.current.getBoundingClientRect();\n        const scaledX = (e.clientX - rect.left - startPos.x) / scaleFactor;\n        const scaledY = (e.clientY - rect.top - startPos.y) / scaleFactor;\n        const x = scaledX / img.current.width;\n        const y = scaledY / img.current.height;\n        const distance = currentPolygon.length > 0 ? distanceBetween(x, y, currentPolygon[0][0], currentPolygon[0][1]) : Number.MAX_VALUE;\n        setCurrentPolygon((prev)=>[\n                ...prev,\n                [\n                    x,\n                    y\n                ]\n            ]);\n        if (currentPolygon.length > 2 && distance < completionThreshold) {\n            const newPolygon = {\n                labelIndex: 12,\n                // points: [...currentPolygon, currentPolygon[0]],\n                points: [\n                    ...currentPolygon,\n                    [\n                        x,\n                        y\n                    ]\n                ],\n                prediction: 0.95,\n                color: getColorForPolygon(12)\n            };\n            setPolygons((prev)=>[\n                    ...prev,\n                    newPolygon\n                ]);\n            setCurrentPolygon([]);\n        }\n        let foundPolygonIndex = null;\n        polygons.forEach((polygon, index)=>{\n            if (polygon.prediction >= predictionRange) {\n                foundPolygonIndex = index;\n            }\n        });\n        setSelectedPolygonIndex(foundPolygonIndex !== null ? foundPolygonIndex : \"None\");\n    }, [\n        showModal,\n        currentPolygon,\n        polygons,\n        startPos,\n        scaleFactor,\n        img\n    ]);\n    const handleCanvasRightClick = (e)=>{\n        e.preventDefault();\n        if (currentPolygon.length > 0) {\n            setCurrentPolygon([]);\n            return;\n        }\n        setShowModal(true);\n        setModalPos({\n            x: e.clientX + window.scrollX,\n            y: e.clientY + window.scrollY\n        });\n        const rect = canvasRef.current.getBoundingClientRect();\n        const mouseX = (e.clientX - rect.left - startPos.x) / scaleFactor;\n        const mouseY = (e.clientY - rect.top - startPos.y) / scaleFactor;\n        let foundPolygonIndex = null;\n        polygons.forEach((polygon, index)=>{\n            if (isMouseInPolygon(mouseX, mouseY, polygon)) {\n                foundPolygonIndex = index;\n                setModalPolygonIndex(index);\n            }\n        });\n        setModalPolygonIndex(foundPolygonIndex);\n        if (foundPolygonIndex !== null) {\n            setModalPolygonIndex(foundPolygonIndex);\n        } else {\n            setCurrentPolygon([]);\n        }\n    };\n    const isMouseInPolygon = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((mouseX, mouseY, polygon)=>{\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.save();\n        ctx.setTransform(scaleFactor, 0, 0, scaleFactor, startPos.x, startPos.y);\n        ctx.beginPath();\n        if (polygon && Array.isArray(polygon.points)) {\n            polygon.points.forEach((param, index)=>{\n                let [x, y] = param;\n                const polyX = x * img.current.width;\n                const polyY = y * img.current.height;\n                if (index === 0) {\n                    ctx.moveTo(polyX, polyY);\n                } else {\n                    ctx.lineTo(polyX, polyY);\n                }\n            });\n        }\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        const isInPath = ctx.isPointInPath(mouseX, mouseY);\n        ctx.restore();\n        return isInPath;\n    }, [\n        scaleFactor,\n        startPos,\n        img\n    ]);\n    const handleMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        if (e.button === 1) {\n            setIsWheelDown(true);\n            dragStart.current = {\n                x: e.clientX,\n                y: e.clientY\n            };\n            e.currentTarget.style.cursor = \"grabbing\";\n        } else if (e.button === 0) {\n            const rect = canvasRef.current.getBoundingClientRect();\n            const mouseX = e.clientX - rect.left;\n            const mouseY = e.clientY - rect.top;\n            let foundPolygon = false;\n            polygons.forEach((polygon)=>{\n                if (isMouseInPolygon(mouseX, mouseY, polygon)) {\n                    setSelectedPolygonIndex(polygon.labelIndex);\n                    foundPolygon = true;\n                }\n            });\n            if (!foundPolygon) {\n                setSelectedPolygonIndex(\"None\");\n            }\n        }\n    }, [\n        polygons,\n        isWheelDown\n    ]);\n    const handleMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        if (isWheelDown) {\n            const newOffset = {\n                x: startPos.x + (e.clientX - dragStart.current.x),\n                y: startPos.y + (e.clientY - dragStart.current.y)\n            };\n            setStartPos(newOffset);\n            dragStart.current = {\n                x: e.clientX,\n                y: e.clientY\n            };\n            e.preventDefault();\n        } else {\n            const rect = canvasRef.current.getBoundingClientRect();\n            const mouseX = e.clientX - rect.left;\n            const mouseY = e.clientY - rect.top;\n            let foundPolygon = false;\n            polygons.forEach((polygon)=>{\n                if (isMouseInPolygon(mouseX, mouseY, polygon)) {\n                    setSelectedPolygonIndex(polygon.labelIndex);\n                    foundPolygon = true;\n                }\n            });\n            if (!foundPolygon) {\n                setSelectedPolygonIndex(\"None\");\n            }\n        }\n    }, [\n        isWheelDown,\n        polygons,\n        startPos\n    ]);\n    const handleMouseUp = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        if (e.button === 1) {\n            e.preventDefault();\n            setIsWheelDown(false);\n            e.currentTarget.style.cursor = \"default\";\n        }\n    }, []);\n    const handleWheel = (e)=>{\n        if (!isWheelDown) {\n            const delta = Math.sign(e.deltaY);\n            setScaleFactor((prevScale)=>{\n                let newScale = delta > 0 ? prevScale + 0.1 : Math.max(prevScale - 0.1, 0.1);\n                return newScale;\n            });\n        }\n    };\n    const handleFileChange = (e)=>{\n        const file = e.target.files[0];\n        if (!file) {\n            return;\n        }\n        const reader = new FileReader();\n        reader.onload = (e)=>{\n            const content = e.target.result;\n            setFileContent(content);\n            processFileContent(content);\n        };\n        reader.readAsText(file);\n    };\n    const processFileContent = (content)=>{\n        const jsonData = JSON.parse(content);\n        const loadedPolygons = Object.values(jsonData).map((item)=>{\n            const itemStr = typeof item === \"string\" ? item.trim() : JSON.stringify(item).trim();\n            const parts = itemStr.split(\" \");\n            const labelIndex = parseInt(parts[0], 10);\n            const predictionValue = parseFloat(parts[parts.length - 1]);\n            const points = parts.slice(1, -1).map((part, index, array)=>index % 2 === 0 ? [\n                    parseFloat(array[index]),\n                    parseFloat(array[index + 1])\n                ] : null).filter((point)=>point);\n            const color = getColorForPolygon(labelIndex);\n            return {\n                labelIndex,\n                points,\n                prediction: predictionValue,\n                color\n            };\n        });\n        setPolygons(loadedPolygons);\n    };\n    const handleDeletePolygon = ()=>{\n        if (modalPolygonIndex !== null) {\n            setPolygons((prev)=>prev.filter((_, index)=>index !== modalPolygonIndex));\n        }\n        setShowModal(false);\n        setModalPolygonIndex(null);\n    };\n    const handleModalInputUpdate = (modalInputValue)=>{\n        if (modalPolygonIndex !== null) {\n            const updatedPolygons = polygons.map((polygon, index)=>{\n                if (index === modalPolygonIndex) {\n                    return {\n                        ...polygon,\n                        tag: modalInputValue.tag,\n                        description: modalInputValue.description\n                    };\n                }\n                return polygon;\n            });\n            setPolygons(updatedPolygons);\n        }\n        setShowModal(false);\n    };\n    const handleAddPhotoMount = (newPhotoMount)=>{\n        setPhotoMounts([\n            ...photoMounts,\n            newPhotoMount\n        ]);\n    };\n    return /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"input\", {\n                type: \"file\",\n                onChange: handleFileChange\n            }, void 0, false, {\n                fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                lineNumber: 428,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"p\", {\n                children: [\n                    \"예측값 범위: \",\n                    /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"span\", {\n                        children: predictionRange\n                    }, void 0, false, {\n                        fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                        lineNumber: 429,\n                        columnNumber: 18\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                lineNumber: 429,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"input\", {\n                type: \"range\",\n                min: \"0\",\n                max: \"1\",\n                step: \"0.01\",\n                value: predictionRange,\n                onChange: (e)=>setPredictionRange(e.target.value)\n            }, void 0, false, {\n                fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                lineNumber: 430,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                width: 700,\n                height: 900,\n                onMouseDown: handleMouseDown,\n                onMouseUp: handleMouseUp,\n                onMouseMove: handleMouseMove,\n                onClick: handleCanvasClick,\n                onContextMenu: handleCanvasRightClick,\n                onWheel: handleWheel\n            }, void 0, false, {\n                fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                lineNumber: 438,\n                columnNumber: 7\n            }, undefined),\n            showModal && /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(_components_CanvasModal__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {\n                modalPos: modalPos,\n                onDelete: handleDeletePolygon,\n                onModalInputUpdate: handleModalInputUpdate,\n                setShowModal: setShowModal,\n                currentData: polygons[modalPolygonIndex]\n            }, void 0, false, {\n                fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                lineNumber: 450,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"p\", {\n                children: [\n                    \"선택된 폴리곤 라벨 인덱스: \",\n                    /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"span\", {\n                        children: selectedPolygonIndex\n                    }, void 0, false, {\n                        fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                        lineNumber: 458,\n                        columnNumber: 26\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                lineNumber: 458,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"button\", {\n                onClick: ()=>setScaleFactor(scaleFactor + 0.1),\n                children: \"확대\"\n            }, void 0, false, {\n                fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                lineNumber: 459,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"button\", {\n                onClick: ()=>setScaleFactor(scaleFactor - 0.1),\n                children: \"축소\"\n            }, void 0, false, {\n                fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n                lineNumber: 460,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/iinjae/Desktop/drawing-space/src/app/page.tsx\",\n        lineNumber: 427,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Canvas, \"gz6RqbnfNcn7XUdwYYxGhFVTaRs=\");\n_c = Canvas;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Canvas);\nvar _c;\n$RefreshReg$(_c, \"Canvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OzBCQUFNOzs7Ozs7MEJBQzFELHVFQUFDMkg7Z0JBQU9nRSxTQUFTLElBQU0xTCxlQUFlRCxjQUFjOzBCQUFNOzs7Ozs7Ozs7Ozs7QUFHaEU7R0FyY01QO0tBQUFBO0FBdWNOLCtEQUFlQSxNQUFNQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvcGFnZS50c3g/ZjY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeEltcG9ydFNvdXJjZSBAZW1vdGlvbi9yZWFjdCAqL1xuXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBDYW52YXNNb2RhbCBmcm9tICdAL2NvbXBvbmVudHMvQ2FudmFzTW9kYWwnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cblxuXG5jb25zdCBDYW52YXMgPSAoKSA9PiB7XG4gIGNvbnN0IFtwb2x5Z29ucywgc2V0UG9seWdvbnNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbc2VsZWN0ZWRQb2x5Z29uSW5kZXgsIHNldFNlbGVjdGVkUG9seWdvbkluZGV4XSA9IHVzZVN0YXRlKCdOb25lJyk7XG4gIGNvbnN0IFtwcmVkaWN0aW9uUmFuZ2UsIHNldFByZWRpY3Rpb25SYW5nZV0gPSB1c2VTdGF0ZSgwLjUpO1xuICBjb25zdCBbc2NhbGVGYWN0b3IsIHNldFNjYWxlRmFjdG9yXSA9IHVzZVN0YXRlKDEuMCk7XG4gIGNvbnN0IFtjdXJyZW50UG9seWdvbiwgc2V0Q3VycmVudFBvbHlnb25dID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbaXNXaGVlbERvd24sIHNldElzV2hlZWxEb3duXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3N0YXJ0UG9zLCBzZXRTdGFydFBvc10gPSB1c2VTdGF0ZSh7IHg6IDAsIHk6IDAgfSk7XG4gIGNvbnN0IFtmaWxlQ29udGVudCwgc2V0RmlsZUNvbnRlbnRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbc2hvd01vZGFsLCBzZXRTaG93TW9kYWxdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbbW9kYWxQb3MsIHNldE1vZGFsUG9zXSA9IHVzZVN0YXRlKHsgeDogMCwgeTogMCB9KTtcbiAgY29uc3QgW21vZGFsUG9seWdvbkluZGV4LCBzZXRNb2RhbFBvbHlnb25JbmRleF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2hvdmVyZWRQb2x5Z29uSW5kZXgsIHNldEhvdmVyZWRQb2x5Z29uSW5kZXhdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtwaG90b01vdW50cywgc2V0UGhvdG9Nb3VudHNdID0gdXNlU3RhdGUoW10pO1xuICBcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBkcmFnU3RhcnQgPSB1c2VSZWYoeyB4OiAwLCB5OiAwIH0pO1xuICBjb25zdCBpbWcgPSB1c2VSZWYobmV3IEltYWdlKCkpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIHBvbHlnb25zLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgICBpZiAocG9seWdvbi5sYWJlbEluZGV4ID09PSBzZWxlY3RlZFBvbHlnb25JbmRleCAmJiBwb2x5Z29uLnByZWRpY3Rpb24gPj0gcHJlZGljdGlvblJhbmdlKSB7XG4gICAgICAgIGlzVmlzaWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIFxuICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICBzZXRTZWxlY3RlZFBvbHlnb25JbmRleCgnTm9uZScpO1xuICAgIH1cbiAgfSwgW3ByZWRpY3Rpb25SYW5nZSwgcG9seWdvbnMsIHNlbGVjdGVkUG9seWdvbkluZGV4XSk7MFxuXG4gIGNvbnN0IGdldENvbG9yRm9yUG9seWdvbiA9IHVzZUNhbGxiYWNrKChsYWJlbEluZGV4KSA9PiB7XG4gICAgY29uc3QgY29sb3JzID0gW1xuICAgICAgJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJyxcbiAgICAgICdyZ2JhKDI1NSwgMTQwLCAwLCAwLjUpJyxcbiAgICAgICdyZ2JhKDI1NSwgMjU1LCAwLCAwLjUpJyxcbiAgICAgICdyZ2JhKDAsIDI1NSwgMCwgMC41KScsXG4gICAgICAncmdiYSgwLCAwLCAyNTUsIDAuNSknLFxuICAgICAgJ3JnYmEoMjU1LCAxNTMsIDUwNCwgMC41KScsXG4gICAgXTtcbiAgICByZXR1cm4gY29sb3JzW2xhYmVsSW5kZXggJSBjb2xvcnMubGVuZ3RoXTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGluY3JlYXNlT3BhY2l0eSA9IChjb2xvcikgPT4ge1xuICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IGNvbG9yLm1hdGNoKC9cXGQrL2cpLm1hcChOdW1iZXIpO1xuICAgIGNvbnN0IGluY3JlYXNlZE9wYWNpdHkgPSBNYXRoLm1pbihhICsgMC4yLCAxKTtcbiAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHtpbmNyZWFzZWRPcGFjaXR5fSlgO1xuICB9XG5cbiAgY29uc3QgZHJhd1BvbHlnb24gPSB1c2VDYWxsYmFjaygocG9seWdvbiwgY3R4KSA9PiB7XG4gICAgaWYgKHBvbHlnb24ucHJlZGljdGlvbiA8IHByZWRpY3Rpb25SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgbGV0IGZpbGxDb2xvciA9IHBvbHlnb24uY29sb3I7XG4gICAgaWYgKHBvbHlnb24ubGFiZWxJbmRleCA9PT0gc2VsZWN0ZWRQb2x5Z29uSW5kZXggfHwgXG4gICAgICAgIHBvbHlnb24ubGFiZWxJbmRleCA9PT0gbW9kYWxQb2x5Z29uSW5kZXggfHwgXG4gICAgICAgIGhvdmVyZWRQb2x5Z29uSW5kZXggPT09IHBvbHlnb24ubGFiZWxJbmRleCkge1xuICAgICAgZmlsbENvbG9yID0gaW5jcmVhc2VPcGFjaXR5KGZpbGxDb2xvcik7XG4gICAgfVxuICBcbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBwb2x5Z29uLnBvaW50cy5mb3JFYWNoKChbeCwgeV0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBhZGp1c3RlZFggPSB4ICogaW1nLmN1cnJlbnQud2lkdGg7XG4gICAgICBjb25zdCBhZGp1c3RlZFkgPSB5ICogaW1nLmN1cnJlbnQuaGVpZ2h0O1xuICAgICAgXG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhhZGp1c3RlZFgsIGFkanVzdGVkWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVRvKGFkanVzdGVkWCwgYWRqdXN0ZWRZKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICBjb25zdCBjZW50cm9pZCA9IHBvbHlnb24ucG9pbnRzLnJlZHVjZSgoYWNjLCBbeCwgeV0pID0+IHtcbiAgICAgIGFjYy54ICs9IHg7XG4gICAgICBhY2MueSArPSB5O1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7IHg6IDAsIHk6IDAgfSk7XG4gICAgY2VudHJvaWQueCA9IChjZW50cm9pZC54IC8gcG9seWdvbi5wb2ludHMubGVuZ3RoKSAqIGltZy5jdXJyZW50LndpZHRoICogc2NhbGVGYWN0b3IgKyBzdGFydFBvcy54O1xuICAgIGNlbnRyb2lkLnkgPSAoY2VudHJvaWQueSAvIHBvbHlnb24ucG9pbnRzLmxlbmd0aCkgKiBpbWcuY3VycmVudC5oZWlnaHQgKiBzY2FsZUZhY3RvciArIHN0YXJ0UG9zLnk7XG4gIFxuICAgIGlmIChwb2x5Z29uLnRhZyB8fCBwb2x5Z29uLmRlc2NyaXB0aW9uKSB7XG4gICAgICBjdHguZm9udCA9ICcxNnB4IEFyaWFsJztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnYmxhY2snO1xuICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgbGV0IHRleHRUb0Rpc3BsYXkgPSBwb2x5Z29uLnRhZztcbiAgICAgIGN0eC5maWxsVGV4dCh0ZXh0VG9EaXNwbGF5LCBjZW50cm9pZC54LCBjZW50cm9pZC55KTtcbiAgICB9XG4gIH0sIFtwcmVkaWN0aW9uUmFuZ2UsIHNlbGVjdGVkUG9seWdvbkluZGV4LCBtb2RhbFBvbHlnb25JbmRleCwgaG92ZXJlZFBvbHlnb25JbmRleCwgc2NhbGVGYWN0b3IsIHN0YXJ0UG9zLCBpbWddKTtcblxuICBjb25zdCBkcmF3Q3VycmVudFBvbHlnb24gPSB1c2VDYWxsYmFjaygoY3R4KSA9PiB7XG4gICAgaWYgKGN1cnJlbnRQb2x5Z29uLmxlbmd0aCA+IDApIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN1cnJlbnRQb2x5Z29uLmZvckVhY2goKFt4LCB5XSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4ICogaW1nLmN1cnJlbnQud2lkdGgsIHkgKiBpbWcuY3VycmVudC5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5saW5lVG8oeCAqIGltZy5jdXJyZW50LndpZHRoLCB5ICogaW1nLmN1cnJlbnQuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9LCBbY3VycmVudFBvbHlnb25dKTtcblxuICBjb25zdCBkcmF3SW1hZ2VBbmRQb2x5Z29ucyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHN0YXJ0UG9zLngsIHN0YXJ0UG9zLnkpO1xuICAgIGN0eC5zY2FsZShzY2FsZUZhY3Rvciwgc2NhbGVGYWN0b3IpO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nLmN1cnJlbnQsIDAsIDApO1xuXG4gICAgLy8gcG9seWdvbnMuZm9yRWFjaChwb2x5Z29uID0+IGRyYXdQb2x5Z29uKHBvbHlnb24sIGN0eCkpO1xuICAgIHBvbHlnb25zLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgICBpZihwb2x5Z29uLnByZWRpY3Rpb24gPj0gcHJlZGljdGlvblJhbmdlKSB7XG4gICAgICAgIGRyYXdQb2x5Z29uKHBvbHlnb24sIGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZHJhd0N1cnJlbnRQb2x5Z29uKGN0eCk7XG5cbiAgICAvLyBwb2x5Z29ucy5mb3JFYWNoKChwb2x5Z29uLCBpbmRleCkgPT4ge1xuICAgIC8vICAgZHJhd1BvbHlnb24ocG9seWdvbiwgY3R4LCBpbmRleCk7XG4gICAgLy8gfSk7XG5cbiAgICAvLyB0YWdzLmZvckVhY2godGFnID0+IHtcbiAgICAvLyAgIGN0eC5maWxsVGV4dCh0YWcudGV4dCwgdGFnLngsIHRhZy55KTtcbiAgICAvLyB9KTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sIFtwb2x5Z29ucywgZHJhd1BvbHlnb24sIHN0YXJ0UG9zLCBzY2FsZUZhY3Rvcl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW1nLmN1cnJlbnQuc3JjID0gJy90ZXN0NTguanBnJztcbiAgICBpbWcuY3VycmVudC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBkcmF3SW1hZ2VBbmRQb2x5Z29ucygpO1xuICAgIH07XG4gIH0sIFtkcmF3SW1hZ2VBbmRQb2x5Z29uc10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZHJhd0ltYWdlQW5kUG9seWdvbnMoKTtcbiAgfSwgW3ByZWRpY3Rpb25SYW5nZSwgZHJhd0ltYWdlQW5kUG9seWdvbnNdKTtcblxuICAvLyBjb25zdCBpc05lYXJTdGFydFBvaW50ID0gKHBvaW50LCBzdGFydFBvaW50KSA9PiB7XG4gIC8vICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnRbMF0gLSBzdGFydFBvaW50WzBdLCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gc3RhcnRQb2ludFsxXSwgMikpO1xuICAvLyAgIHJldHVybiBkaXN0YW5jZSA8IDAuMDE7XG4gIC8vIH07XG5cbiAgLy8gY29uc3QgZHJhd0N1cnJlbnRQb2x5Z29uV2l0aE5ld1BvaW50ID0gdXNlQ2FsbGJhY2soKG5ld1BvaW50KSA9PiB7XG4gIC8vICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gIC8vICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIC8vICAgZHJhd0N1cnJlbnRQb2x5Z29uKGN0eCk7XG5cbiAgLy8gICBpZiAoY3VycmVudFBvbHlnb24ubGVuZ3RoID4gMCkge1xuICAvLyAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAvLyAgICAgY3VycmVudFBvbHlnb24uZm9yRWFjaCgocG9pbnQsIGluZGV4KSA9PiB7XG4gIC8vICAgICAgIGNvbnN0IGFkanVzdGVkWCA9IHBvaW50WzBdICogY2FudmFzLndpZHRoO1xuICAvLyAgICAgICBjb25zdCBhZGp1c3RlZFkgPSBwb2ludFsxXSAqIGNhbnZhcy5oZWlnaHQ7XG5cbiAgLy8gICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gIC8vICAgICAgICAgY3R4Lm1vdmVUbyhhZGp1c3RlZFgsIGFkanVzdGVkWSk7XG4gIC8vICAgICAgIH0gZWxzZSB7XG4gIC8vICAgICAgICAgY3R4LmxpbmVUbyhhZGp1c3RlZFgsIGFkanVzdGVkWSk7XG4gIC8vICAgICAgIH1cblxuICAvLyAgICAgICBjb25zb2xlLmxvZyhhZGp1c3RlZFgsIGFkanVzdGVkWSk7XG4gIC8vICAgICB9KTtcbiAgLy8gICAgIGN0eC5saW5lVG8obmV3UG9pbnRbMF0gKiBjYW52YXMud2lkdGgsIG5ld1BvaW50WzFdICogY2FudmFzLmhlaWdodCk7XG4gIC8vICAgICBjdHguc3Ryb2tlKCk7XG4gIC8vICAgfVxuICAvLyB9LCBbY3VycmVudFBvbHlnb24sIGRyYXdDdXJyZW50UG9seWdvbl0pO1xuXG4gIGNvbnN0IGRpc3RhbmNlQmV0d2VlbiA9ICh4MSwgeTEsIHgyLCB5MikgPT4ge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4MSwgMikgKyBNYXRoLnBvdyh5MiAtIHkxLCAyKSk7XG4gIH1cblxuICBjb25zdCBoYW5kbGVDYW52YXNDbGljayA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgaWYgKHNob3dNb2RhbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxldGlvblRocmVzaG9sZCA9IDAuMDA3XG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgc2NhbGVkWCA9IChlLmNsaWVudFggLSByZWN0LmxlZnQgLSBzdGFydFBvcy54KSAvIHNjYWxlRmFjdG9yO1xuICAgIGNvbnN0IHNjYWxlZFkgPSAoZS5jbGllbnRZIC0gcmVjdC50b3AgLSBzdGFydFBvcy55KSAvIHNjYWxlRmFjdG9yO1xuICAgIGNvbnN0IHggPSBzY2FsZWRYIC8gaW1nLmN1cnJlbnQud2lkdGg7XG4gICAgY29uc3QgeSA9IHNjYWxlZFkgLyBpbWcuY3VycmVudC5oZWlnaHQ7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBjdXJyZW50UG9seWdvbi5sZW5ndGggPiAwID8gZGlzdGFuY2VCZXR3ZWVuKHgsIHksIGN1cnJlbnRQb2x5Z29uWzBdWzBdLCBjdXJyZW50UG9seWdvblswXVsxXSkgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgc2V0Q3VycmVudFBvbHlnb24ocHJldiA9PiBbLi4ucHJldiwgW3gsIHldXSk7XG5cbiAgICBpZiAoY3VycmVudFBvbHlnb24ubGVuZ3RoID4gMiAmJiBkaXN0YW5jZSA8IGNvbXBsZXRpb25UaHJlc2hvbGQpIHtcbiAgICAgIGNvbnN0IG5ld1BvbHlnb24gPSB7XG4gICAgICAgIGxhYmVsSW5kZXg6IDEyLFxuICAgICAgICAvLyBwb2ludHM6IFsuLi5jdXJyZW50UG9seWdvbiwgY3VycmVudFBvbHlnb25bMF1dLFxuICAgICAgICBwb2ludHM6IFsuLi5jdXJyZW50UG9seWdvbiwgW3gsIHldXSxcbiAgICAgICAgcHJlZGljdGlvbjogMC45NSxcbiAgICAgICAgY29sb3I6IGdldENvbG9yRm9yUG9seWdvbigxMilcbiAgICAgIH07XG4gICAgICBzZXRQb2x5Z29ucyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdQb2x5Z29uXSk7XG4gICAgICBzZXRDdXJyZW50UG9seWdvbihbXSk7XG4gICAgfVxuXG4gICAgbGV0IGZvdW5kUG9seWdvbkluZGV4ID0gbnVsbDtcbiAgICBwb2x5Z29ucy5mb3JFYWNoKChwb2x5Z29uLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHBvbHlnb24ucHJlZGljdGlvbiA+PSBwcmVkaWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgZm91bmRQb2x5Z29uSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNldFNlbGVjdGVkUG9seWdvbkluZGV4KGZvdW5kUG9seWdvbkluZGV4ICE9PSBudWxsID8gZm91bmRQb2x5Z29uSW5kZXggOiAnTm9uZScpO1xuXG4gIH0sW3Nob3dNb2RhbCwgY3VycmVudFBvbHlnb24sIHBvbHlnb25zLCBzdGFydFBvcywgc2NhbGVGYWN0b3IsIGltZ10pO1xuXG4gIGNvbnN0IGhhbmRsZUNhbnZhc1JpZ2h0Q2xpY2sgPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmIChjdXJyZW50UG9seWdvbi5sZW5ndGggPiAwKSB7XG4gICAgICBzZXRDdXJyZW50UG9seWdvbihbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0U2hvd01vZGFsKHRydWUpO1xuICAgIHNldE1vZGFsUG9zKHtcbiAgICAgIHg6IGUuY2xpZW50WCArIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgeTogZS5jbGllbnRZICsgd2luZG93LnNjcm9sbFkgXG4gICAgfSk7XG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgbW91c2VYID0gKGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIHN0YXJ0UG9zLngpIC8gc2NhbGVGYWN0b3I7XG4gICAgY29uc3QgbW91c2VZID0gKGUuY2xpZW50WSAtIHJlY3QudG9wIC0gc3RhcnRQb3MueSkgLyBzY2FsZUZhY3RvcjtcblxuICAgIGxldCBmb3VuZFBvbHlnb25JbmRleCA9IG51bGw7XG4gICAgcG9seWdvbnMuZm9yRWFjaCgocG9seWdvbiwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpc01vdXNlSW5Qb2x5Z29uKG1vdXNlWCwgbW91c2VZLCBwb2x5Z29uKSkge1xuICAgICAgICBmb3VuZFBvbHlnb25JbmRleCA9IGluZGV4O1xuICAgICAgICBzZXRNb2RhbFBvbHlnb25JbmRleChpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2V0TW9kYWxQb2x5Z29uSW5kZXgoZm91bmRQb2x5Z29uSW5kZXgpO1xuXG4gICAgaWYgKGZvdW5kUG9seWdvbkluZGV4ICE9PSBudWxsKSB7XG4gICAgICBzZXRNb2RhbFBvbHlnb25JbmRleChmb3VuZFBvbHlnb25JbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEN1cnJlbnRQb2x5Z29uKFtdKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaXNNb3VzZUluUG9seWdvbiA9IHVzZUNhbGxiYWNrKChtb3VzZVgsIG1vdXNlWSwgcG9seWdvbikgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShzY2FsZUZhY3RvciwgMCwgMCwgc2NhbGVGYWN0b3IsIHN0YXJ0UG9zLngsIHN0YXJ0UG9zLnkpO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgaWYgKHBvbHlnb24gJiYgQXJyYXkuaXNBcnJheShwb2x5Z29uLnBvaW50cykpIHtcbiAgICAgIHBvbHlnb24ucG9pbnRzLmZvckVhY2goKFt4LCB5XSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcG9seVggPSB4ICogaW1nLmN1cnJlbnQud2lkdGg7XG4gICAgICAgIGNvbnN0IHBvbHlZID0geSAqIGltZy5jdXJyZW50LmhlaWdodDtcblxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBjdHgubW92ZVRvKHBvbHlYLCBwb2x5WSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyhwb2x5WCwgcG9seVkpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gICAgXG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjb25zdCBpc0luUGF0aCA9IGN0eC5pc1BvaW50SW5QYXRoKG1vdXNlWCwgbW91c2VZKTtcbiAgICBcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHJldHVybiBpc0luUGF0aDtcbiAgfSwgW3NjYWxlRmFjdG9yLCBzdGFydFBvcywgaW1nXSk7XG5cbiAgY29uc3QgaGFuZGxlTW91c2VEb3duID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICBpZiAoZS5idXR0b24gPT09IDEpIHtcbiAgICAgIHNldElzV2hlZWxEb3duKHRydWUpO1xuICAgICAgZHJhZ1N0YXJ0LmN1cnJlbnQgPSB7IHg6IGUuY2xpZW50WCwgeTogZS5jbGllbnRZIH07XG4gICAgICBlLmN1cnJlbnRUYXJnZXQuc3R5bGUuY3Vyc29yID0gJ2dyYWJiaW5nJztcbiAgICB9IGVsc2UgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICBjb25zdCByZWN0ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBtb3VzZVggPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICBjb25zdCBtb3VzZVkgPSBlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgXG4gICAgICBsZXQgZm91bmRQb2x5Z29uID0gZmFsc2U7XG4gIFxuICAgICAgcG9seWdvbnMuZm9yRWFjaChwb2x5Z29uID0+IHtcbiAgICAgICAgaWYgKGlzTW91c2VJblBvbHlnb24obW91c2VYLCBtb3VzZVksIHBvbHlnb24pKSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRQb2x5Z29uSW5kZXgocG9seWdvbi5sYWJlbEluZGV4KTtcbiAgICAgICAgICBmb3VuZFBvbHlnb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgXG4gICAgICBpZiAoIWZvdW5kUG9seWdvbikge1xuICAgICAgICBzZXRTZWxlY3RlZFBvbHlnb25JbmRleCgnTm9uZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3BvbHlnb25zLCBpc1doZWVsRG93bl0pO1xuICBcbiBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgIGlmIChpc1doZWVsRG93bikge1xuICAgICAgY29uc3QgbmV3T2Zmc2V0ID0ge1xuICAgICAgICB4OiBzdGFydFBvcy54ICsgKGUuY2xpZW50WCAtIGRyYWdTdGFydC5jdXJyZW50LngpLFxuICAgICAgICB5OiBzdGFydFBvcy55ICsgKGUuY2xpZW50WSAtIGRyYWdTdGFydC5jdXJyZW50LnkpLFxuICAgICAgfTtcbiAgICAgIHNldFN0YXJ0UG9zKG5ld09mZnNldCk7XG4gICAgICBkcmFnU3RhcnQuY3VycmVudCA9IHsgeDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFkgfTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgeyBcbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXNSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IG1vdXNlWCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgIGNvbnN0IG1vdXNlWSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuICBcbiAgICAgIGxldCBmb3VuZFBvbHlnb24gPSBmYWxzZTtcbiAgICAgIHBvbHlnb25zLmZvckVhY2goKHBvbHlnb24pID0+IHtcbiAgICAgICAgaWYgKGlzTW91c2VJblBvbHlnb24obW91c2VYLCBtb3VzZVksIHBvbHlnb24pKSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRQb2x5Z29uSW5kZXgocG9seWdvbi5sYWJlbEluZGV4KTtcbiAgICAgICAgICBmb3VuZFBvbHlnb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICBcbiAgICAgIGlmICghZm91bmRQb2x5Z29uKSB7XG4gICAgICAgIHNldFNlbGVjdGVkUG9seWdvbkluZGV4KFwiTm9uZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpc1doZWVsRG93biwgcG9seWdvbnMsIHN0YXJ0UG9zXSk7XG4gIFxuICBjb25zdCBoYW5kbGVNb3VzZVVwID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICBpZiAoZS5idXR0b24gPT09IDEpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNldElzV2hlZWxEb3duKGZhbHNlKTtcbiAgICAgIGUuY3VycmVudFRhcmdldC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3QgaGFuZGxlV2hlZWwgPSAoZSkgPT4ge1xuICAgIGlmICghaXNXaGVlbERvd24pIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5zaWduKGUuZGVsdGFZKTtcbiAgICAgIHNldFNjYWxlRmFjdG9yKHByZXZTY2FsZSA9PiB7XG4gICAgICAgIGxldCBuZXdTY2FsZSA9IGRlbHRhID4gMCA/IHByZXZTY2FsZSArIDAuMSA6IE1hdGgubWF4KHByZXZTY2FsZSAtIDAuMSwgMC4xKTtcbiAgICAgICAgcmV0dXJuIG5ld1NjYWxlO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUZpbGVDaGFuZ2UgPSAoZSkgPT4ge1xuICAgIGNvbnN0IGZpbGUgPSBlLnRhcmdldC5maWxlc1swXTtcbiAgICBpZiAoIWZpbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgc2V0RmlsZUNvbnRlbnQoY29udGVudCk7XG4gICAgICBwcm9jZXNzRmlsZUNvbnRlbnQoY29udGVudCk7XG4gICAgfTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgfTtcblxuICBjb25zdCBwcm9jZXNzRmlsZUNvbnRlbnQgPSAoY29udGVudCkgPT4ge1xuICAgIGNvbnN0IGpzb25EYXRhID0gSlNPTi5wYXJzZShjb250ZW50KTtcbiAgICBjb25zdCBsb2FkZWRQb2x5Z29ucyA9IE9iamVjdC52YWx1ZXMoanNvbkRhdGEpLm1hcChpdGVtID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1TdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgPyBpdGVtLnRyaW0oKSA6IEpTT04uc3RyaW5naWZ5KGl0ZW0pLnRyaW0oKTtcblxuICAgICAgY29uc3QgcGFydHMgPSBpdGVtU3RyLnNwbGl0KCcgJyk7XG4gICAgICBjb25zdCBsYWJlbEluZGV4ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTtcbiAgICAgIGNvbnN0IHByZWRpY3Rpb25WYWx1ZSA9IHBhcnNlRmxvYXQocGFydHNbcGFydHMubGVuZ3RoIC0gMV0pO1xuICAgICAgY29uc3QgcG9pbnRzID0gcGFydHNcbiAgICAgICAgLnNsaWNlKDEsIC0xKVxuICAgICAgICAubWFwKChwYXJ0LCBpbmRleCwgYXJyYXkpID0+XG4gICAgICAgICAgaW5kZXggJSAyID09PSAwID8gW3BhcnNlRmxvYXQoYXJyYXlbaW5kZXhdKSwgcGFyc2VGbG9hdChhcnJheVtpbmRleCArIDFdKV0gOiBudWxsXG4gICAgICAgIClcbiAgICAgICAgLmZpbHRlcihwb2ludCA9PiBwb2ludCk7XG4gICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yRm9yUG9seWdvbihsYWJlbEluZGV4KTtcbiAgICAgIHJldHVybiB7IGxhYmVsSW5kZXgsIHBvaW50cywgcHJlZGljdGlvbjogcHJlZGljdGlvblZhbHVlLCBjb2xvciB9O1xuICAgIH0pO1xuICAgIHNldFBvbHlnb25zKGxvYWRlZFBvbHlnb25zKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVEZWxldGVQb2x5Z29uID0gKCkgPT4ge1xuICAgIGlmIChtb2RhbFBvbHlnb25JbmRleCAhPT0gbnVsbCkge1xuICAgICAgc2V0UG9seWdvbnMocHJldiA9PiBwcmV2LmZpbHRlcigoXywgaW5kZXgpID0+IGluZGV4ICE9PSBtb2RhbFBvbHlnb25JbmRleCkpO1xuICAgIH1cbiAgICBzZXRTaG93TW9kYWwoZmFsc2UpO1xuICAgIHNldE1vZGFsUG9seWdvbkluZGV4KG51bGwpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZU1vZGFsSW5wdXRVcGRhdGUgPSAobW9kYWxJbnB1dFZhbHVlKSA9PiB7XG4gICAgaWYgKG1vZGFsUG9seWdvbkluZGV4ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB1cGRhdGVkUG9seWdvbnMgPSBwb2x5Z29ucy5tYXAoKHBvbHlnb24sIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gbW9kYWxQb2x5Z29uSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4geyAuLi5wb2x5Z29uLCB0YWc6IG1vZGFsSW5wdXRWYWx1ZS50YWcsIGRlc2NyaXB0aW9uOiBtb2RhbElucHV0VmFsdWUuZGVzY3JpcHRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9seWdvbjtcbiAgICAgIH0pO1xuICAgICAgc2V0UG9seWdvbnModXBkYXRlZFBvbHlnb25zKTtcbiAgICB9XG4gICAgc2V0U2hvd01vZGFsKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVBZGRQaG90b01vdW50ID0gKG5ld1Bob3RvTW91bnQpID0+IHtcbiAgICBzZXRQaG90b01vdW50cyhbLi4ucGhvdG9Nb3VudHMsIG5ld1Bob3RvTW91bnRdKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gLz5cbiAgICAgIDxwPuyYiOy4oeqwkiDrspTsnIQ6IDxzcGFuPntwcmVkaWN0aW9uUmFuZ2V9PC9zcGFuPjwvcD5cbiAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJyYW5nZVwiXG4gICAgICAgICAgbWluPVwiMFwiXG4gICAgICAgICAgbWF4PVwiMVwiXG4gICAgICAgICAgc3RlcD1cIjAuMDFcIlxuICAgICAgICAgIHZhbHVlPXtwcmVkaWN0aW9uUmFuZ2V9XG4gICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRQcmVkaWN0aW9uUmFuZ2UoZS50YXJnZXQudmFsdWUpfVxuICAgICAgLz5cbiAgICAgIDxjYW52YXNcbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICAgIHdpZHRoPXs3MDB9XG4gICAgICAgIGhlaWdodD17OTAwfVxuICAgICAgICBvbk1vdXNlRG93bj17aGFuZGxlTW91c2VEb3dufVxuICAgICAgICBvbk1vdXNlVXA9e2hhbmRsZU1vdXNlVXB9XG4gICAgICAgIG9uTW91c2VNb3ZlPXtoYW5kbGVNb3VzZU1vdmV9XG4gICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNhbnZhc0NsaWNrfVxuICAgICAgICBvbkNvbnRleHRNZW51PXtoYW5kbGVDYW52YXNSaWdodENsaWNrfVxuICAgICAgICBvbldoZWVsPXtoYW5kbGVXaGVlbH1cbiAgICAgIC8+XG4gICAgICB7c2hvd01vZGFsICYmIChcbiAgICAgICAgPENhbnZhc01vZGFsXG4gICAgICAgICAgbW9kYWxQb3M9e21vZGFsUG9zfVxuICAgICAgICAgIG9uRGVsZXRlPXtoYW5kbGVEZWxldGVQb2x5Z29ufVxuICAgICAgICAgIG9uTW9kYWxJbnB1dFVwZGF0ZT17aGFuZGxlTW9kYWxJbnB1dFVwZGF0ZX1cbiAgICAgICAgICBzZXRTaG93TW9kYWw9e3NldFNob3dNb2RhbH1cbiAgICAgICAgICBjdXJyZW50RGF0YT17cG9seWdvbnNbbW9kYWxQb2x5Z29uSW5kZXhdfVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIDxwPuyEoO2DneuQnCDtj7Trpqzqs6Qg652867KoIOyduOuNseyKpDogPHNwYW4+e3NlbGVjdGVkUG9seWdvbkluZGV4fTwvc3Bhbj48L3A+XG4gICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFNjYWxlRmFjdG9yKHNjYWxlRmFjdG9yICsgMC4xKX0+7ZmV64yAPC9idXR0b24+XG4gICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFNjYWxlRmFjdG9yKHNjYWxlRmFjdG9yIC0gMC4xKX0+7LaV7IaMPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhczsiXSwibmFtZXMiOlsiQ2FudmFzTW9kYWwiLCJSZWFjdCIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJDYW52YXMiLCJwb2x5Z29ucyIsInNldFBvbHlnb25zIiwic2VsZWN0ZWRQb2x5Z29uSW5kZXgiLCJzZXRTZWxlY3RlZFBvbHlnb25JbmRleCIsInByZWRpY3Rpb25SYW5nZSIsInNldFByZWRpY3Rpb25SYW5nZSIsInNjYWxlRmFjdG9yIiwic2V0U2NhbGVGYWN0b3IiLCJjdXJyZW50UG9seWdvbiIsInNldEN1cnJlbnRQb2x5Z29uIiwiaXNXaGVlbERvd24iLCJzZXRJc1doZWVsRG93biIsInN0YXJ0UG9zIiwic2V0U3RhcnRQb3MiLCJ4IiwieSIsImZpbGVDb250ZW50Iiwic2V0RmlsZUNvbnRlbnQiLCJzaG93TW9kYWwiLCJzZXRTaG93TW9kYWwiLCJtb2RhbFBvcyIsInNldE1vZGFsUG9zIiwibW9kYWxQb2x5Z29uSW5kZXgiLCJzZXRNb2RhbFBvbHlnb25JbmRleCIsImhvdmVyZWRQb2x5Z29uSW5kZXgiLCJzZXRIb3ZlcmVkUG9seWdvbkluZGV4IiwicGhvdG9Nb3VudHMiLCJzZXRQaG90b01vdW50cyIsImNhbnZhc1JlZiIsImRyYWdTdGFydCIsImltZyIsIkltYWdlIiwiaXNWaXNpYmxlIiwiZm9yRWFjaCIsInBvbHlnb24iLCJsYWJlbEluZGV4IiwicHJlZGljdGlvbiIsImdldENvbG9yRm9yUG9seWdvbiIsImNvbG9ycyIsImxlbmd0aCIsImluY3JlYXNlT3BhY2l0eSIsImNvbG9yIiwiciIsImciLCJiIiwiYSIsIm1hdGNoIiwibWFwIiwiTnVtYmVyIiwiaW5jcmVhc2VkT3BhY2l0eSIsIk1hdGgiLCJtaW4iLCJkcmF3UG9seWdvbiIsImN0eCIsImZpbGxDb2xvciIsImJlZ2luUGF0aCIsInBvaW50cyIsImluZGV4IiwiYWRqdXN0ZWRYIiwiY3VycmVudCIsIndpZHRoIiwiYWRqdXN0ZWRZIiwiaGVpZ2h0IiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwiZmlsbFN0eWxlIiwiZmlsbCIsInN0cm9rZSIsImNlbnRyb2lkIiwicmVkdWNlIiwiYWNjIiwidGFnIiwiZGVzY3JpcHRpb24iLCJmb250IiwidGV4dEFsaWduIiwidGV4dFRvRGlzcGxheSIsImZpbGxUZXh0IiwiZHJhd0N1cnJlbnRQb2x5Z29uIiwiZHJhd0ltYWdlQW5kUG9seWdvbnMiLCJjYW52YXMiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0Iiwic2F2ZSIsInRyYW5zbGF0ZSIsInNjYWxlIiwiZHJhd0ltYWdlIiwicmVzdG9yZSIsInNyYyIsIm9ubG9hZCIsImRpc3RhbmNlQmV0d2VlbiIsIngxIiwieTEiLCJ4MiIsInkyIiwic3FydCIsInBvdyIsImhhbmRsZUNhbnZhc0NsaWNrIiwiZSIsImNvbXBsZXRpb25UaHJlc2hvbGQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2NhbGVkWCIsImNsaWVudFgiLCJsZWZ0Iiwic2NhbGVkWSIsImNsaWVudFkiLCJ0b3AiLCJkaXN0YW5jZSIsIk1BWF9WQUxVRSIsInByZXYiLCJuZXdQb2x5Z29uIiwiZm91bmRQb2x5Z29uSW5kZXgiLCJoYW5kbGVDYW52YXNSaWdodENsaWNrIiwicHJldmVudERlZmF1bHQiLCJ3aW5kb3ciLCJzY3JvbGxYIiwic2Nyb2xsWSIsIm1vdXNlWCIsIm1vdXNlWSIsImlzTW91c2VJblBvbHlnb24iLCJzZXRUcmFuc2Zvcm0iLCJBcnJheSIsImlzQXJyYXkiLCJwb2x5WCIsInBvbHlZIiwiaXNJblBhdGgiLCJpc1BvaW50SW5QYXRoIiwiaGFuZGxlTW91c2VEb3duIiwiYnV0dG9uIiwiY3VycmVudFRhcmdldCIsInN0eWxlIiwiY3Vyc29yIiwiZm91bmRQb2x5Z29uIiwiaGFuZGxlTW91c2VNb3ZlIiwibmV3T2Zmc2V0IiwiaGFuZGxlTW91c2VVcCIsImhhbmRsZVdoZWVsIiwiZGVsdGEiLCJzaWduIiwiZGVsdGFZIiwicHJldlNjYWxlIiwibmV3U2NhbGUiLCJtYXgiLCJoYW5kbGVGaWxlQ2hhbmdlIiwiZmlsZSIsInRhcmdldCIsImZpbGVzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsImNvbnRlbnQiLCJyZXN1bHQiLCJwcm9jZXNzRmlsZUNvbnRlbnQiLCJyZWFkQXNUZXh0IiwianNvbkRhdGEiLCJKU09OIiwicGFyc2UiLCJsb2FkZWRQb2x5Z29ucyIsIk9iamVjdCIsInZhbHVlcyIsIml0ZW0iLCJpdGVtU3RyIiwidHJpbSIsInN0cmluZ2lmeSIsInBhcnRzIiwic3BsaXQiLCJwYXJzZUludCIsInByZWRpY3Rpb25WYWx1ZSIsInBhcnNlRmxvYXQiLCJzbGljZSIsInBhcnQiLCJhcnJheSIsImZpbHRlciIsInBvaW50IiwiaGFuZGxlRGVsZXRlUG9seWdvbiIsIl8iLCJoYW5kbGVNb2RhbElucHV0VXBkYXRlIiwibW9kYWxJbnB1dFZhbHVlIiwidXBkYXRlZFBvbHlnb25zIiwiaGFuZGxlQWRkUGhvdG9Nb3VudCIsIm5ld1Bob3RvTW91bnQiLCJkaXYiLCJpbnB1dCIsInR5cGUiLCJvbkNoYW5nZSIsInAiLCJzcGFuIiwic3RlcCIsInZhbHVlIiwicmVmIiwib25Nb3VzZURvd24iLCJvbk1vdXNlVXAiLCJvbk1vdXNlTW92ZSIsIm9uQ2xpY2siLCJvbkNvbnRleHRNZW51Iiwib25XaGVlbCIsIm9uRGVsZXRlIiwib25Nb2RhbElucHV0VXBkYXRlIiwiY3VycmVudERhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ })

});